=== E:/repos/CPP_Codebase_Processor/CMakeLists.txt ===
cmake_minimum_required(VERSION 3.16.0)

project(codebase_processor LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Qt configuration
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

# Adjust this path to match your Qt installation
set(CMAKE_PREFIX_PATH "E:/QT/6.8.2/msvc2022_64")

# Find Qt packages
find_package(Qt6 REQUIRED COMPONENTS 
    Core
    Gui
    Widgets
)

# List all our source files
add_executable(codebase_processor
    main.cpp
    MainWindow.cpp
    MainWindow.h
    FileProcessingWorker.cpp
    FileProcessingWorker.h
    FileSystemModelWithGitIgnore.cpp
    FileSystemModelWithGitIgnore.h
    ProcessingDialog.cpp 
    ProcessingDialog.h
    resources.qrc
)

# Link against Qt libraries
target_link_libraries(codebase_processor PRIVATE
    Qt::Core
    Qt::Gui
    Qt::Widgets
) 

# Deployment configuration for Windows
if(WIN32)
    # Find windeployqt executable
    get_target_property(_qmake_executable Qt::qmake IMPORTED_LOCATION)
    get_filename_component(_qt_bin_dir "${_qmake_executable}" DIRECTORY)
    find_program(WINDEPLOYQT_EXECUTABLE windeployqt HINTS "${_qt_bin_dir}")

    # Add deployment command
    add_custom_command(TARGET codebase_processor POST_BUILD
    COMMAND "${WINDEPLOYQT_EXECUTABLE}"
        --release  # <-- Instead of --debug
        --no-compiler-runtime
        --no-translations
        --no-system-d3d-compiler
        "$<TARGET_FILE:codebase_processor>"
    COMMENT "Deploying Qt dependencies..."
)

    # Copy Visual C++ runtime
    include(InstallRequiredSystemLibraries)
    if(CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS)
        add_custom_command(TARGET codebase_processor POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS} $<TARGET_FILE_DIR:codebase_processor>
            COMMENT "Copying Visual C++ runtime libraries..."
        )
    endif()
endif() 

=== E:/repos/CPP_Codebase_Processor/FileProcessingWorker.cpp ===
#include "FileProcessingWorker.h"
#include "FileSystemModelWithGitIgnore.h"
#include <QFile>
#include <QTextStream>
#include <QRegularExpression>
#include <QFileInfo>
#include <QDebug>
#include <QThread>  // Added for QThread::msleep

FileProcessingWorker::FileProcessingWorker(
    const QString& path, 
    const std::set<QString>& files,
    FileSystemModelWithGitIgnore* model,
    QObject* parent
) : QObject(parent)
  , rootPath(path)
  , selectedFiles(files)
  , fileModel(model)
  , totalProcessedSize(0) {
}

void FileProcessingWorker::process() {
    QString result;
    
    // Filter out non-processable files first
    std::set<QString> processableFiles;
    for (const QString& filePath : selectedFiles) {
        if (fileModel->shouldIncludeFile(filePath)) {
            processableFiles.insert(filePath);
        }
    }
    
    // Use processable files for total count
    int totalFiles = processableFiles.size();
    emit processingProgress(0, totalFiles);

    int processedFiles = 0;
    for (const QString& filePath : processableFiles) {
        emit currentFile(filePath);
        QFile file(filePath);
        
        if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {
            QByteArray content = file.readAll();
            result += "=== " + filePath + " ===\n";
            result += QString::fromUtf8(content);
            result += "\n\n";
            
            totalProcessedSize += content.size();
            processedFiles++;
            
            // Update progress and statistics
            emit processingProgress(processedFiles, totalFiles);
            emit statistics(processedFiles, totalProcessedSize);
            
            // Give the UI a chance to update
            QThread::msleep(1);
        } else {
            emit error(QString("Could not open file: %1 - %2")
                      .arg(filePath)
                      .arg(file.errorString()));
            return;
        }
    }

    if (result.isEmpty()) {
        emit error("No files were processed. Please check your selection.");
        return;
    }

    emit finished(result);
}

=== E:/repos/CPP_Codebase_Processor/FileProcessingWorker.h ===
// FileProcessingWorker.h
#pragma once

#include <QObject>
#include <QString>
#include <set>

class FileSystemModelWithGitIgnore;

class FileProcessingWorker : public QObject {
    Q_OBJECT

public:
    explicit FileProcessingWorker(
        const QString& rootPath, 
        const std::set<QString>& selectedFiles,
        FileSystemModelWithGitIgnore* model,
        QObject* parent = nullptr
    );

public slots:
    void process();

signals:
    void processingProgress(int current, int total);
    void currentFile(const QString& filePath);
    void statistics(int processedFiles, qint64 totalSize);
    void finished(const QString& result);
    void error(const QString& message);

private:
    QString rootPath;
    std::set<QString> selectedFiles;
    FileSystemModelWithGitIgnore* fileModel;
    qint64 totalProcessedSize;
};

=== E:/repos/CPP_Codebase_Processor/FileSystemModelWithGitIgnore.cpp ===
#include "FileSystemModelWithGitIgnore.h"
#include <QFile>
#include <QTextStream>
#include <QRegularExpression>
#include <QFileInfo>
#include <QDebug>

FileSystemModelWithGitIgnore::FileSystemModelWithGitIgnore(QObject* parent)
    : QFileSystemModel(parent)
    , isInitialized(false) {
    // Defer initialization of patterns until they're actually needed
    setFilter(QDir::AllEntries | QDir::NoDotAndDotDot | QDir::Hidden);
}

FileSystemModelWithGitIgnore::~FileSystemModelWithGitIgnore() {
}

void FileSystemModelWithGitIgnore::initializeDefaultPatterns() {
    defaultIgnorePatterns = {
        ".vs/*",       // Visual Studio folder
        "build/*",     // Build output directory
        "out/*",       // Output directory
        "Debug/*",     // Debug build folder
        "Release/*",   // Release build folder
        "x64/*",       // Architecture-specific build folders
        "x86/*",
        "bin/*",       // Binary output directories
        "obj/*",       // Object file directories
        "dist/*",      // Distribution directory
        
        // Ignore compiled and binary files
        "*.exe",
        "*.dll",
        "*.obj",
        "*.pdb",
        "*.lib",
        "*.log",
        "*.cache",
        
        // IDE and system files
        "*.user",
        "*.suo",
        "*.sln",
        ".DS_Store",
        "Thumbs.db"
    };
    isInitialized = true;
}


Qt::ItemFlags FileSystemModelWithGitIgnore::flags(const QModelIndex& index) const {
    return QFileSystemModel::flags(index) | Qt::ItemIsUserCheckable;
}

void FileSystemModelWithGitIgnore::updateGitIgnorePatterns(const QString& rootPath) {
    if (!isInitialized) {
        initializeDefaultPatterns();
    }

    projectRootPath = rootPath;
    gitIgnorePatterns.clear();
    
    QFile gitignore(rootPath + "/.gitignore");
    if (gitignore.open(QIODevice::ReadOnly | QIODevice::Text)) {
        QTextStream in(&gitignore);
        while (!in.atEnd()) {
            QString line = in.readLine().trimmed();
            if (!line.isEmpty() && !line.startsWith('#')) {
                if (line.endsWith("/")) {
                    line += "*";
                }
                gitIgnorePatterns.append(line);
            }
        }
        gitignore.close();
    }
}

QString FileSystemModelWithGitIgnore::getRelativePath(const QString& path) const {
    return QDir(projectRootPath).relativeFilePath(path);
}

bool FileSystemModelWithGitIgnore::isPathIgnored(const QString& path) const {
    QString relativePath = getRelativePath(path);
    
    // Check default patterns first
    for (const QString& pattern : defaultIgnorePatterns) {
        QRegularExpression rx(QRegularExpression::wildcardToRegularExpression(pattern),
                            QRegularExpression::CaseInsensitiveOption);
        if (rx.match(relativePath).hasMatch()) {
            return true;
        }
    }

    // Then check gitignore patterns
    for (const QString& pattern : gitIgnorePatterns) {
        QRegularExpression rx(QRegularExpression::wildcardToRegularExpression(pattern),
                            QRegularExpression::CaseInsensitiveOption);
        if (rx.match(relativePath).hasMatch()) {
            return true;
        }
    }

    return false;
}


bool FileSystemModelWithGitIgnore::isFileProcessable(const QString& filePath) const {
    QFileInfo fileInfo(filePath);
    
    // Explicitly reject certain directories
    if (fileInfo.isDir()) {
        QString dirName = fileInfo.fileName();
        if (dirName == ".vs" || dirName == "build" || dirName == "out" || 
            dirName == "Debug" || dirName == "Release" || 
            dirName == "bin" || dirName == "obj") {
            return false;
        }
        return true;  // Allow other directories
    }
    
    // Check file extension whitelist for text-based files
    QString ext = fileInfo.suffix().toLower();
    QStringList allowedExtensions = {
        "cpp", "h", "hpp", "c", "txt", "md", "cmake", 
        "json", "yml", "yaml", "bat", "sh", "cs", 
        "py", "js", "ts", "html", "css", "xml", 
        "ini", "toml"
    };
    
    return !isPathIgnored(filePath) && allowedExtensions.contains(ext);
}

QVariant FileSystemModelWithGitIgnore::data(const QModelIndex& index, int role) const {
    if (!isInitialized || !index.isValid()) {
        return QFileSystemModel::data(index, role);
    }

    if (role == Qt::CheckStateRole && index.column() == 0) {
        QString path = filePath(index);
        QFileInfo fileInfo(path);
        
        // Don't show checkboxes for directories
        if (fileInfo.isDir()) {
            return QVariant();
        }
        
        // Allow manual selection of all files, regardless of .gitignore rules
        return QFileSystemModel::data(index, role);
    }
    return QFileSystemModel::data(index, role);
}

bool FileSystemModelWithGitIgnore::shouldIncludeFile(const QString& filePath) const {
    if (!isInitialized) {
        return true;
    }
    return isFileProcessable(filePath);
}

=== E:/repos/CPP_Codebase_Processor/FileSystemModelWithGitIgnore.h ===
// FileSystemModelWithGitIgnore.h
#pragma once

#include <QFileSystemModel>
#include <QStringList>
#include <QDir>

class FileSystemModelWithGitIgnore : public QFileSystemModel {
    Q_OBJECT

public:
    explicit FileSystemModelWithGitIgnore(QObject* parent = nullptr);
    ~FileSystemModelWithGitIgnore();

    QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
    Qt::ItemFlags flags(const QModelIndex& index) const override;
    void updateGitIgnorePatterns(const QString& rootPath);
    bool shouldIncludeFile(const QString& filePath) const;

private:
    QStringList gitIgnorePatterns;
    QStringList defaultIgnorePatterns;
    QString projectRootPath;
    bool isInitialized;

    void initializeDefaultPatterns();
    bool isPathIgnored(const QString& path) const;
    QString getRelativePath(const QString& path) const;
    bool isFileProcessable(const QString& filePath) const;
};

=== E:/repos/CPP_Codebase_Processor/MainWindow.cpp ===
#include "MainWindow.h"
#include "FileSystemModelWithGitIgnore.h"
#include "ProcessingDialog.h"
#include "FileProcessingWorker.h"

#include <QVBoxLayout>
#include <QPushButton>
#include <QTreeView>
#include <QFileDialog>
#include <QMessageBox>
#include <QFile>
#include <QTextStream>
#include <QDirIterator>
#include <QClipboard>
#include <QApplication>
#include <QFileSystemWatcher>
#include <QThread>
#include <QTimer>
#include <QStandardPaths>
#include <QItemSelectionModel>
#include <QDebug>

MainWindow::MainWindow(QWidget *parent) 
    : QMainWindow(parent)
    , workerThread(nullptr)
{
    // Only do minimal setup initially
    setWindowTitle("Codebase Processor");
    resize(800, 600);
    
    // Use QTimer to defer the rest of the initialization
    QTimer::singleShot(0, this, &MainWindow::delayedInit);
}

void MainWindow::delayedInit()
{
    setupUI();
    
    // Additional setup for file model
    fileModel->setFilter(QDir::AllEntries | QDir::NoDotAndDotDot | QDir::Hidden);
}

MainWindow::~MainWindow()
{
    // If there's an active worker thread, clean it up
    if (workerThread && workerThread->isRunning()) {
        workerThread->quit();
        workerThread->wait();
    }
}

void MainWindow::setupUI()
{
    centralWidget = new QWidget(this);
    setCentralWidget(centralWidget);
    mainLayout = new QVBoxLayout(centralWidget);

    // Create folder selection button
    selectFolderButton = new QPushButton("Select Codebase Folder", this);
    connect(selectFolderButton, &QPushButton::clicked, this, &MainWindow::selectFolder);
    mainLayout->addWidget(selectFolderButton);

    // Create tree view but defer model setup
    fileTreeView = new QTreeView(this);
    fileTreeView->setUniformRowHeights(true);
    fileTreeView->setEnabled(false);
    fileTreeView->setSortingEnabled(false); // Enable only after folder selection
    // Make sure multi-selection is enabled so multiple files can be selected
    fileTreeView->setSelectionMode(QAbstractItemView::MultiSelection);
    fileTreeView->setSelectionBehavior(QAbstractItemView::SelectRows);
    mainLayout->addWidget(fileTreeView);

    // Create action buttons
    saveFileButton = new QPushButton("Save to File", this);
    saveClipboardButton = new QPushButton("Copy to Clipboard", this);
    
    connect(saveFileButton, &QPushButton::clicked, this, &MainWindow::saveToFile);
    connect(saveClipboardButton, &QPushButton::clicked, this, &MainWindow::saveToClipboard);

    mainLayout->addWidget(saveFileButton);
    mainLayout->addWidget(saveClipboardButton);

    // Disable buttons initially
    saveFileButton->setEnabled(false);
    saveClipboardButton->setEnabled(false);

    // Initialize file system model
    fileModel = new FileSystemModelWithGitIgnore(this);
    fileModel->setReadOnly(true);
    fileTreeView->setModel(fileModel);

    // Set up selection handling after model is set
    connect(fileTreeView->selectionModel(), &QItemSelectionModel::selectionChanged,
            this, &MainWindow::handleSelectionChanged);

    // Set up gitignore watcher
    gitignoreWatcher = new QFileSystemWatcher(this);
    connect(gitignoreWatcher, &QFileSystemWatcher::fileChanged,
            this, &MainWindow::onGitIgnoreChanged);
}

void MainWindow::selectFolder()
{
    QString dir = QFileDialog::getExistingDirectory(
        this,
        "Select Codebase Directory",
        QString(),
        QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks
    );

    if (!dir.isEmpty()) {
        QApplication::setOverrideCursor(Qt::WaitCursor);
        
        // Use a timer to allow the UI to update
        QTimer::singleShot(0, this, [this, dir]() {
            currentPath = dir;
            
            // Set up the model with the new path
            QModelIndex rootIndex = fileModel->setRootPath(dir);
            fileTreeView->setRootIndex(rootIndex);
            
            // Update .gitignore patterns if present
            QString gitignorePath = dir + "/.gitignore";
            if (QFile::exists(gitignorePath)) {
                gitignoreWatcher->addPath(gitignorePath);
                fileModel->updateGitIgnorePatterns(dir);
            }
            
            // Expand the entire directory tree
            expandEntireDirectoryTree(rootIndex);

            // Manually populate selection
            QDir directory(dir);
            QStringList files = directory.entryList(
                QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot, 
                QDir::Name
            );
            
            selectedFiles.clear();
            for (const QString& fileName : files) {
                QString fullPath = dir + QDir::separator() + fileName;
                if (fileModel->shouldIncludeFile(fullPath)) {
                    selectedFiles.insert(fullPath);
                    qDebug() << "Manually adding:" << fullPath;
                }
            }
            
            qDebug() << "Manually selected files:" << selectedFiles.size();

            // Programmatically select these files in the tree
            fileTreeView->selectionModel()->clearSelection();
            for (const QString &filePath : selectedFiles) {
                QModelIndex index = fileModel->index(filePath);
                if (index.isValid()) {
                    fileTreeView->selectionModel()->select(
                        index,
                        QItemSelectionModel::Select | QItemSelectionModel::Rows
                    );
                }
            }
            
            // Enable UI elements
            fileTreeView->setEnabled(true);
            saveFileButton->setEnabled(true);
            saveClipboardButton->setEnabled(true);
            fileTreeView->setSortingEnabled(true);
            
            QApplication::restoreOverrideCursor();
        });
    }
}

void MainWindow::expandEntireDirectoryTree(const QModelIndex& parentIndex, int depth)
{
    // Prevent excessive recursion
    if (depth > 10) return;
    
    // Expand the current index
    fileTreeView->expand(parentIndex);
    
    // Get the number of rows (child items) for this parent
    int rows = fileModel->rowCount(parentIndex);
    
    // Iterate through all child items
    for (int i = 0; i < rows; ++i) {
        QModelIndex childIndex = fileModel->index(i, 0, parentIndex);
        
        // If this is a directory, recursively expand it
        if (fileModel->isDir(childIndex)) {
            expandEntireDirectoryTree(childIndex, depth + 1);
        }
    }
}

void MainWindow::handleSelectionChanged(const QItemSelection& selected, 
                                        const QItemSelection& deselected)
{
    // Process newly selected items
    for (const QModelIndex& index : selected.indexes()) {
        if (index.column() == 0) {  // Only process the first column
            QString filePath = fileModel->filePath(index);
            // Check if it's a file
            QFileInfo fileInfo(filePath);
            if (fileInfo.isFile()) {
                selectedFiles.insert(filePath);
                qDebug() << "Added to selection:" << filePath;
            }
        }
    }
    
    // Process deselected items
    for (const QModelIndex& index : deselected.indexes()) {
        if (index.column() == 0) {  // Only process the first column
            QString filePath = fileModel->filePath(index);
            selectedFiles.erase(filePath);
            qDebug() << "Removed from selection:" << filePath;
        }
    }
    
    qDebug() << "Total files selected:" << selectedFiles.size();
}

void MainWindow::expandDirectory(const QModelIndex& index, int depth)
{
    if (depth <= 0) return;
    
    fileTreeView->expand(index);
    int rows = fileModel->rowCount(index);
    
    for (int i = 0; i < rows; ++i) {
        QModelIndex childIndex = fileModel->index(i, 0, index);
        if (fileModel->isDir(childIndex)) {
            expandDirectory(childIndex, depth - 1);
        }
    }
}

void MainWindow::onGitIgnoreChanged()
{
    // When .gitignore changes, update the patterns and refresh the view
    fileModel->updateGitIgnorePatterns(currentPath);
}

void MainWindow::startFileProcessing(bool toClipboard)
{
    // Debug output to help diagnose selection issues
    qDebug() << "Starting processing with" << selectedFiles.size() << "files selected";
    for (const QString& file : selectedFiles) {
        qDebug() << "Selected file:" << file;
    }

    // Validate that we have files to process
    if (selectedFiles.empty()) {
        QMessageBox::warning(this, "No Files Selected",
                           "Please select files to process first.");
        return;
    }

    // Create a set of files that should actually be processed
    std::set<QString> filesToProcess;
    for (const QString& filePath : selectedFiles) {
        if (fileModel->shouldIncludeFile(filePath)) {
            QFileInfo fileInfo(filePath);
            if (fileInfo.isFile()) {
                filesToProcess.insert(filePath);
                qDebug() << "Will process:" << filePath;
            }
        }
    }

    if (filesToProcess.empty()) {
        QMessageBox::warning(this, "No Valid Files",
                           "None of the selected items can be processed. Please select valid files.");
        return;
    }

    // Create processing dialog
    auto* dialog = new ProcessingDialog(this);
    dialog->setWindowTitle(toClipboard ? "Copying to Clipboard" : "Saving to File");
    dialog->show();
    qApp->processEvents();

    // Create worker thread
    auto* worker = new FileProcessingWorker(currentPath, filesToProcess, fileModel);
    workerThread = new QThread(this);
    worker->moveToThread(workerThread);

    // Connect all signals
    connect(worker, &FileProcessingWorker::processingProgress, 
            dialog, &ProcessingDialog::setProgress);
    connect(worker, &FileProcessingWorker::currentFile,
            dialog, &ProcessingDialog::setCurrentFile);
    connect(worker, &FileProcessingWorker::statistics,
            dialog, &ProcessingDialog::updateStatistics);

    // Handle completion
    connect(worker, &FileProcessingWorker::finished, this, 
            [this, dialog, worker, toClipboard](const QString& result) {
        // Clean up worker thread
        workerThread->quit();
        worker->deleteLater();
        dialog->hide();

        // Get the final statistics
        int processedFiles = dialog->processedFiles() ;
        QString totalSize = dialog->formatFileSize(dialog->totalSize());

        if (result.isEmpty()) {
            QMessageBox::warning(this, "Processing Result", 
                               "No content was processed. Please check your file selection.");
        } else if (toClipboard) {
            QClipboard* clipboard = QApplication::clipboard();
            clipboard->setText(result);
            QMessageBox::information(this, "Success",
                QString("Content copied to clipboard successfully!\n\n"
                        "Files processed: %1\nTotal size: %2")
                .arg(processedFiles).arg(totalSize));
        } else {
            // Create a default filename
            QString defaultFileName = QFileInfo(currentPath).fileName() + "_processed.txt";
            QString defaultPath = QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);
            QString defaultFilePath = QDir(defaultPath).filePath(defaultFileName);

            QString savePath = QFileDialog::getSaveFileName(
                this,
                "Save Processed Code",
                defaultFilePath,
                "Text Files (*.txt);;Markdown Files (*.md);;All Files (*.*)",
                nullptr,
                QFileDialog::DontUseNativeDialog
            );

            if (!savePath.isEmpty()) {
                QFile file(savePath);
                if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {
                    QTextStream out(&file);
                    out << result;
                    file.close();
                    QMessageBox::information(this, "Success",
                        QString("Files successfully processed and saved!\n\n"
                                "Files processed: %1\nTotal size: %2")
                        .arg(processedFiles).arg(totalSize));
                } else {
                    QMessageBox::critical(this, "Error",
                        "Could not save the file: " + file.errorString());
                }
            }
        }

        dialog->deleteLater();
    });

    // Handle errors
    connect(worker, &FileProcessingWorker::error, this, 
            [this, dialog](const QString& message) {
        dialog->hide();
        dialog->deleteLater();
        QMessageBox::critical(this, "Error", message);
    });

    // Ensure proper cleanup
    connect(workerThread, &QThread::finished, worker, &QObject::deleteLater);
    connect(workerThread, &QThread::finished, workerThread, &QObject::deleteLater);

    // Start processing
    connect(workerThread, &QThread::started, worker, &FileProcessingWorker::process);
    workerThread->start();

    qDebug() << "Processing thread started";
}

void MainWindow::saveToClipboard()
{
    startFileProcessing(true);
}

void MainWindow::saveToFile()
{
    startFileProcessing(false);
}

=== E:/repos/CPP_Codebase_Processor/MainWindow.h ===
// MainWindow.h
// This header defines our main application window and declares all its functionality.
#pragma once

#include <QMainWindow>
#include <QString>
#include <set>

// Forward declarations to reduce header dependencies
class QTreeView;
class QPushButton;
class QVBoxLayout;
class QFileSystemWatcher;
class FileSystemModelWithGitIgnore;
class ProcessingDialog;
class QItemSelection;

class MainWindow : public QMainWindow {
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private slots:
    void selectFolder();
    void saveToFile();
    void saveToClipboard();
    void onGitIgnoreChanged();
    void handleSelectionChanged(const QItemSelection& selected, const QItemSelection& deselected);

private:
    void delayedInit();
    void setupUI();
    void expandDirectory(const QModelIndex& index, int depth);
    QString processFiles();
    void selectAllProcessableFiles(const QModelIndex& parentIndex);
    void expandEntireDirectoryTree(const QModelIndex& parentIndex, int depth = 0);
    void updateFileSelection(const QString& filePath, bool selected);

    // UI Elements
    QWidget *centralWidget{nullptr};
    QVBoxLayout *mainLayout{nullptr};
    QPushButton *selectFolderButton{nullptr};
    QTreeView *fileTreeView{nullptr};
    QPushButton *saveFileButton{nullptr};
    QPushButton *saveClipboardButton{nullptr};
    
    // Model and data handling
    FileSystemModelWithGitIgnore *fileModel{nullptr};
    QFileSystemWatcher *gitignoreWatcher{nullptr};
    QString currentPath;
    std::set<QString> selectedFiles;
    QThread* workerThread{nullptr};
    void startFileProcessing(bool toClipboard);
};


=== E:/repos/CPP_Codebase_Processor/ProcessingDialog.cpp ===
#include "ProcessingDialog.h"
#include <QVBoxLayout>
#include <QProgressBar>
#include <QLabel>
#include <QDebug>

ProcessingDialog::ProcessingDialog(QWidget* parent) 
    : QDialog(parent, Qt::Dialog | Qt::CustomizeWindowHint | Qt::WindowTitleHint) {
    setModal(true);

    mainLayout = new QVBoxLayout(this);
    
    // Main progress message
    messageLabel = new QLabel("Processing files...", this);
    messageLabel->setAlignment(Qt::AlignCenter);
    mainLayout->addWidget(messageLabel);

    // Current file being processed
    currentFileLabel = new QLabel("Waiting to start...", this);
    currentFileLabel->setAlignment(Qt::AlignLeft);
    currentFileLabel->setWordWrap(true);
    mainLayout->addWidget(currentFileLabel);

    // Statistics label
    statisticsLabel = new QLabel("Files processed: 0\nTotal size: 0 bytes", this);
    statisticsLabel->setAlignment(Qt::AlignLeft);
    mainLayout->addWidget(statisticsLabel);

    // Progress bar
    progressBar = new QProgressBar(this);
    progressBar->setMinimum(0);
    progressBar->setMaximum(100);
    progressBar->setValue(0);
    progressBar->setTextVisible(true);
    mainLayout->addWidget(progressBar);

    // Set a reasonable size for the dialog
    setFixedSize(500, 200);
    setWindowTitle("Processing");
}

void ProcessingDialog::setProgress(int current, int total) {
    if (total <= 0) return;
    
    int percentage = (current * 100) / total;
    progressBar->setValue(percentage);
    messageLabel->setText(QString("Processing files... (%1 of %2)").arg(current).arg(total));
    
    qDebug() << "Progress:" << current << "of" << total;
}

void ProcessingDialog::setCurrentFile(const QString& filePath) {
    QString displayPath = filePath;
    int lastSlash = displayPath.lastIndexOf('/');
    if (lastSlash == -1) lastSlash = displayPath.lastIndexOf('\\');
    
    if (lastSlash != -1) {
        QString fileName = displayPath.mid(lastSlash + 1);
        QString directory = displayPath.left(lastSlash);
        currentFileLabel->setText(QString("Current file: %1\nIn: %2").arg(fileName).arg(directory));
    } else {
        currentFileLabel->setText(QString("Current file: %1").arg(displayPath));
    }
    
    qDebug() << "Processing file:" << filePath;
}

QString ProcessingDialog::formatFileSize(qint64 size) const {
    const char* units[] = {"bytes", "KB", "MB", "GB"};
    int unitIndex = 0;
    double fileSize = size;

    while (fileSize >= 1024 && unitIndex < 3) {
        fileSize /= 1024;
        unitIndex++;
    }

    return QString("%1 %2")
        .arg(fileSize, 0, 'f', unitIndex > 0 ? 2 : 0)
        .arg(units[unitIndex]);
}

void ProcessingDialog::updateStatistics(int processedFiles, qint64 totalSize) {
    m_processedFiles = processedFiles;
    m_totalSize = totalSize;
    statisticsLabel->setText(QString("Files processed: %1\nTotal size: %2")
        .arg(processedFiles)
        .arg(formatFileSize(totalSize)));
    
    qDebug() << "Statistics update - Files:" << processedFiles << "Size:" << formatFileSize(totalSize);
}

=== E:/repos/CPP_Codebase_Processor/ProcessingDialog.h ===
#pragma once

#include <QDialog>
#include <QString>

class QProgressBar;
class QLabel;
class QVBoxLayout;

class ProcessingDialog : public QDialog {
    Q_OBJECT

public:
    explicit ProcessingDialog(QWidget* parent = nullptr);
    int processedFiles() const { return m_processedFiles; }
    qint64 totalSize() const { return m_totalSize; }
    QString formatFileSize(qint64 size) const;

public slots:
    void setProgress(int current, int total);
    void setCurrentFile(const QString& filePath);
    void updateStatistics(int processedFiles, qint64 totalSize);

private:
    QVBoxLayout* mainLayout;
    QLabel* messageLabel;
    QLabel* currentFileLabel;
    QLabel* statisticsLabel;
    QProgressBar* progressBar;
    int m_processedFiles = 0;
    qint64 m_totalSize = 0;
};


=== E:/repos/CPP_Codebase_Processor/README.md ===
# Codebase Processor

A **Qt-based C++** application for processing codebases into a single text file. It allows you to select a folder, choose which files to process based on customizable filters, and then either copy the processed content to your clipboard or save it to a single output file.

## Features

- Recursively scans a selected directory and its subdirectories for code files
- Supports filtering files based on customizable patterns, including a `.gitignore` file if present
- Provides a tree view UI to select individual files to include/exclude from processing
- Concatenates the contents of selected files into a single output, with file paths as headers
- Option to copy the output directly to clipboard or save to a file
- Provides progress updates and statistics during processing
- Cross-platform support (Windows, macOS, Linux)

## Prerequisites

- **Qt 6.8** or higher (adjust `CMAKE_PREFIX_PATH` in `CMakeLists.txt` if needed)
- **CMake 3.16** or higher
- A **C++17** compatible compiler (MSVC, GCC, Clang)
- On Windows, a **Visual Studio Developer Command Prompt** to properly configure the build environment

## Build Instructions

### Automatic Build (Windows)

1. Open a **Developer Command Prompt for Visual Studio**
2. Run either `build_deploy_release.bat` for a Release build or `build_deploy_debug.bat` for a Debug build

The batch file will:
- Set up the Visual Studio build environment 
- Create a `build` directory
- Configure and build the project with CMake
- Deploy the necessary Qt dependencies next to the executable

You can find the final executable in `build\Release` or `build\Debug` depending on the selected build type.

### Manual Build

1. **Create a build directory**: `mkdir build` (or use your preferred build directory setup)
2. **Configure the project with CMake**:
   ```
   cd build
   cmake .. -DCMAKE_BUILD_TYPE=Release
   ```
   (Replace `Release` with `Debug` if you want a debug build)
3. **Build the project**:
   ```
   cmake --build . --config Release
   ```
4. The compiled executable will be in the `Release` or `Debug` subfolder, depending on your build type.

On Windows, you'll also need to run `windeployqt` to copy the necessary Qt dependencies next to the executable:
```
<path_to_qt>\bin\windeployqt.exe --release --no-translations --no-system-d3d-compiler Release\codebase_processor.exe  
```
(Adjust the path to `windeployqt.exe` and the executable as needed)

## Usage

1. Launch the `codebase_processor` executable
2. Click the **"Select Codebase Folder"** button and choose the root directory of the codebase you want to process
3. The file tree will populate with all the code files found in the selected directory and its subdirectories
   - Files ignored based on patterns in a `.gitignore` file (if present) or common binary/build output patterns will be unchecked by default
   - You can manually check/uncheck files to include or exclude them from processing
4. Click **"Copy to Clipboard"** to concatenate the contents of all checked files and copy the result to the clipboard
   - OR click **"Save to File"** to save the concatenated content to a file instead
5. A progress dialog will show the current processing status and statistics
6. Once complete, the processed content will be in your clipboard or saved file

## Contributing

Contributions are welcome! If you encounter any issues or have suggestions for improvements, please open an issue or submit a pull request on the GitHub repository.

## License

This project is open-source and available under the [MIT License](LICENSE).

=== E:/repos/CPP_Codebase_Processor/build_deploy_debug.bat ===
@echo off
setlocal enabledelayedexpansion

:: Check if VS Developer Command Prompt variables are set
if not defined VSINSTALLDIR (
    echo Setting up Visual Studio environment...
    call "E:\Microsoft Visual Studio\2022\Community\Common7\Tools\VsDevCmd.bat"
)

:: Create and enter build directory
if not exist build mkdir build
cd build

:: Configure with CMake
echo Configuring with CMake...
cmake .. -DCMAKE_BUILD_TYPE=Debug

:: Build the project
echo Building the project...
cmake --build . --config Debug

:: Check if build was successful
if %ERRORLEVEL% NEQ 0 (
    echo Build failed!
    pause
    exit /b 1
)

echo Build completed successfully!
echo You can find the executable in build\Debug\
echo Don't forget to run the program from that directory!

pause

=== E:/repos/CPP_Codebase_Processor/build_deploy_release.bat ===
@echo off
setlocal enabledelayedexpansion

:: Check if VS Developer Command Prompt variables are set
if not defined VSINSTALLDIR (
    echo Setting up Visual Studio environment...
    call "E:\Microsoft Visual Studio\2022\Community\Common7\Tools\VsDevCmd.bat"
)

:: Create and enter build directory
if not exist build mkdir build
cd build

:: Configure with CMake for a Release build
echo Configuring with CMake for Release...
cmake .. -DCMAKE_BUILD_TYPE=Release

:: Build the project in Release mode
echo Building the project in Release mode...
cmake --build . --config Release

:: Check if the build was successful
if %ERRORLEVEL% NEQ 0 (
    echo Build failed!
    pause
    exit /b 1
)

:: Optional: Manually run windeployqt in Release mode if needed.
:: Only do this if you want to deploy again outside the built-in CMake steps.
::
:: echo Running windeployqt for Release...
:: "E:\QT\6.8.2\msvc2022_64\bin\windeployqt.exe" --release ^
::     --no-translations ^
::     --no-system-d3d-compiler ^
::     "Release\codebase_processor.exe"

echo Build completed successfully!

:: If you're using the default Visual Studio generator, the final exe is likely in build\Release.
echo You can find the executable in build\Release\ (if using Visual Studio).
echo If using Ninja or MinGW, the exe will be directly in build\.

pause


=== E:/repos/CPP_Codebase_Processor/main.cpp ===
// main.cpp
// This is the entry point of our application. It sets up the Qt application object
// and creates our main window.
#include <QApplication>
#include "MainWindow.h"

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    app.setWindowIcon(QIcon(":/app_icon.png"));
    
    MainWindow window;
    window.show();
    return app.exec();
}

=== E:/repos/CPP_Codebase_Processor\CMakeLists.txt ===
cmake_minimum_required(VERSION 3.16.0)

project(codebase_processor LANGUAGES CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Qt configuration
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

# Adjust this path to match your Qt installation
set(CMAKE_PREFIX_PATH "E:/QT/6.8.2/msvc2022_64")

# Find Qt packages
find_package(Qt6 REQUIRED COMPONENTS 
    Core
    Gui
    Widgets
)

# List all our source files
add_executable(codebase_processor
    main.cpp
    MainWindow.cpp
    MainWindow.h
    FileProcessingWorker.cpp
    FileProcessingWorker.h
    FileSystemModelWithGitIgnore.cpp
    FileSystemModelWithGitIgnore.h
    ProcessingDialog.cpp 
    ProcessingDialog.h
    resources.qrc
)

# Link against Qt libraries
target_link_libraries(codebase_processor PRIVATE
    Qt::Core
    Qt::Gui
    Qt::Widgets
) 

# Deployment configuration for Windows
if(WIN32)
    # Find windeployqt executable
    get_target_property(_qmake_executable Qt::qmake IMPORTED_LOCATION)
    get_filename_component(_qt_bin_dir "${_qmake_executable}" DIRECTORY)
    find_program(WINDEPLOYQT_EXECUTABLE windeployqt HINTS "${_qt_bin_dir}")

    # Add deployment command
    add_custom_command(TARGET codebase_processor POST_BUILD
    COMMAND "${WINDEPLOYQT_EXECUTABLE}"
        --release  # <-- Instead of --debug
        --no-compiler-runtime
        --no-translations
        --no-system-d3d-compiler
        "$<TARGET_FILE:codebase_processor>"
    COMMENT "Deploying Qt dependencies..."
)

    # Copy Visual C++ runtime
    include(InstallRequiredSystemLibraries)
    if(CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS)
        add_custom_command(TARGET codebase_processor POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS} $<TARGET_FILE_DIR:codebase_processor>
            COMMENT "Copying Visual C++ runtime libraries..."
        )
    endif()
endif() 

=== E:/repos/CPP_Codebase_Processor\FileProcessingWorker.cpp ===
#include "FileProcessingWorker.h"
#include "FileSystemModelWithGitIgnore.h"
#include <QFile>
#include <QTextStream>
#include <QRegularExpression>
#include <QFileInfo>
#include <QDebug>
#include <QThread>  // Added for QThread::msleep

FileProcessingWorker::FileProcessingWorker(
    const QString& path, 
    const std::set<QString>& files,
    FileSystemModelWithGitIgnore* model,
    QObject* parent
) : QObject(parent)
  , rootPath(path)
  , selectedFiles(files)
  , fileModel(model)
  , totalProcessedSize(0) {
}

void FileProcessingWorker::process() {
    QString result;
    
    // Filter out non-processable files first
    std::set<QString> processableFiles;
    for (const QString& filePath : selectedFiles) {
        if (fileModel->shouldIncludeFile(filePath)) {
            processableFiles.insert(filePath);
        }
    }
    
    // Use processable files for total count
    int totalFiles = processableFiles.size();
    emit processingProgress(0, totalFiles);

    int processedFiles = 0;
    for (const QString& filePath : processableFiles) {
        emit currentFile(filePath);
        QFile file(filePath);
        
        if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {
            QByteArray content = file.readAll();
            result += "=== " + filePath + " ===\n";
            result += QString::fromUtf8(content);
            result += "\n\n";
            
            totalProcessedSize += content.size();
            processedFiles++;
            
            // Update progress and statistics
            emit processingProgress(processedFiles, totalFiles);
            emit statistics(processedFiles, totalProcessedSize);
            
            // Give the UI a chance to update
            QThread::msleep(1);
        } else {
            emit error(QString("Could not open file: %1 - %2")
                      .arg(filePath)
                      .arg(file.errorString()));
            return;
        }
    }

    if (result.isEmpty()) {
        emit error("No files were processed. Please check your selection.");
        return;
    }

    emit finished(result);
}

=== E:/repos/CPP_Codebase_Processor\FileProcessingWorker.h ===
// FileProcessingWorker.h
#pragma once

#include <QObject>
#include <QString>
#include <set>

class FileSystemModelWithGitIgnore;

class FileProcessingWorker : public QObject {
    Q_OBJECT

public:
    explicit FileProcessingWorker(
        const QString& rootPath, 
        const std::set<QString>& selectedFiles,
        FileSystemModelWithGitIgnore* model,
        QObject* parent = nullptr
    );

public slots:
    void process();

signals:
    void processingProgress(int current, int total);
    void currentFile(const QString& filePath);
    void statistics(int processedFiles, qint64 totalSize);
    void finished(const QString& result);
    void error(const QString& message);

private:
    QString rootPath;
    std::set<QString> selectedFiles;
    FileSystemModelWithGitIgnore* fileModel;
    qint64 totalProcessedSize;
};

=== E:/repos/CPP_Codebase_Processor\FileSystemModelWithGitIgnore.cpp ===
#include "FileSystemModelWithGitIgnore.h"
#include <QFile>
#include <QTextStream>
#include <QRegularExpression>
#include <QFileInfo>
#include <QDebug>

FileSystemModelWithGitIgnore::FileSystemModelWithGitIgnore(QObject* parent)
    : QFileSystemModel(parent)
    , isInitialized(false) {
    // Defer initialization of patterns until they're actually needed
    setFilter(QDir::AllEntries | QDir::NoDotAndDotDot | QDir::Hidden);
}

FileSystemModelWithGitIgnore::~FileSystemModelWithGitIgnore() {
}

void FileSystemModelWithGitIgnore::initializeDefaultPatterns() {
    defaultIgnorePatterns = {
        ".vs/*",       // Visual Studio folder
        "build/*",     // Build output directory
        "out/*",       // Output directory
        "Debug/*",     // Debug build folder
        "Release/*",   // Release build folder
        "x64/*",       // Architecture-specific build folders
        "x86/*",
        "bin/*",       // Binary output directories
        "obj/*",       // Object file directories
        "dist/*",      // Distribution directory
        
        // Ignore compiled and binary files
        "*.exe",
        "*.dll",
        "*.obj",
        "*.pdb",
        "*.lib",
        "*.log",
        "*.cache",
        
        // IDE and system files
        "*.user",
        "*.suo",
        "*.sln",
        ".DS_Store",
        "Thumbs.db"
    };
    isInitialized = true;
}


Qt::ItemFlags FileSystemModelWithGitIgnore::flags(const QModelIndex& index) const {
    return QFileSystemModel::flags(index) | Qt::ItemIsUserCheckable;
}

void FileSystemModelWithGitIgnore::updateGitIgnorePatterns(const QString& rootPath) {
    if (!isInitialized) {
        initializeDefaultPatterns();
    }

    projectRootPath = rootPath;
    gitIgnorePatterns.clear();
    
    QFile gitignore(rootPath + "/.gitignore");
    if (gitignore.open(QIODevice::ReadOnly | QIODevice::Text)) {
        QTextStream in(&gitignore);
        while (!in.atEnd()) {
            QString line = in.readLine().trimmed();
            if (!line.isEmpty() && !line.startsWith('#')) {
                if (line.endsWith("/")) {
                    line += "*";
                }
                gitIgnorePatterns.append(line);
            }
        }
        gitignore.close();
    }
}

QString FileSystemModelWithGitIgnore::getRelativePath(const QString& path) const {
    return QDir(projectRootPath).relativeFilePath(path);
}

bool FileSystemModelWithGitIgnore::isPathIgnored(const QString& path) const {
    QString relativePath = getRelativePath(path);
    
    // Check default patterns first
    for (const QString& pattern : defaultIgnorePatterns) {
        QRegularExpression rx(QRegularExpression::wildcardToRegularExpression(pattern),
                            QRegularExpression::CaseInsensitiveOption);
        if (rx.match(relativePath).hasMatch()) {
            return true;
        }
    }

    // Then check gitignore patterns
    for (const QString& pattern : gitIgnorePatterns) {
        QRegularExpression rx(QRegularExpression::wildcardToRegularExpression(pattern),
                            QRegularExpression::CaseInsensitiveOption);
        if (rx.match(relativePath).hasMatch()) {
            return true;
        }
    }

    return false;
}


bool FileSystemModelWithGitIgnore::isFileProcessable(const QString& filePath) const {
    QFileInfo fileInfo(filePath);
    
    // Explicitly reject certain directories
    if (fileInfo.isDir()) {
        QString dirName = fileInfo.fileName();
        if (dirName == ".vs" || dirName == "build" || dirName == "out" || 
            dirName == "Debug" || dirName == "Release" || 
            dirName == "bin" || dirName == "obj") {
            return false;
        }
        return true;  // Allow other directories
    }
    
    // Check file extension whitelist for text-based files
    QString ext = fileInfo.suffix().toLower();
    QStringList allowedExtensions = {
        "cpp", "h", "hpp", "c", "txt", "md", "cmake", 
        "json", "yml", "yaml", "bat", "sh", "cs", 
        "py", "js", "ts", "html", "css", "xml", 
        "ini", "toml"
    };
    
    return !isPathIgnored(filePath) && allowedExtensions.contains(ext);
}

QVariant FileSystemModelWithGitIgnore::data(const QModelIndex& index, int role) const {
    if (!isInitialized || !index.isValid()) {
        return QFileSystemModel::data(index, role);
    }

    if (role == Qt::CheckStateRole && index.column() == 0) {
        QString path = filePath(index);
        QFileInfo fileInfo(path);
        
        // Don't show checkboxes for directories
        if (fileInfo.isDir()) {
            return QVariant();
        }
        
        // Allow manual selection of all files, regardless of .gitignore rules
        return QFileSystemModel::data(index, role);
    }
    return QFileSystemModel::data(index, role);
}

bool FileSystemModelWithGitIgnore::shouldIncludeFile(const QString& filePath) const {
    if (!isInitialized) {
        return true;
    }
    return isFileProcessable(filePath);
}

=== E:/repos/CPP_Codebase_Processor\FileSystemModelWithGitIgnore.h ===
// FileSystemModelWithGitIgnore.h
#pragma once

#include <QFileSystemModel>
#include <QStringList>
#include <QDir>

class FileSystemModelWithGitIgnore : public QFileSystemModel {
    Q_OBJECT

public:
    explicit FileSystemModelWithGitIgnore(QObject* parent = nullptr);
    ~FileSystemModelWithGitIgnore();

    QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override;
    Qt::ItemFlags flags(const QModelIndex& index) const override;
    void updateGitIgnorePatterns(const QString& rootPath);
    bool shouldIncludeFile(const QString& filePath) const;

private:
    QStringList gitIgnorePatterns;
    QStringList defaultIgnorePatterns;
    QString projectRootPath;
    bool isInitialized;

    void initializeDefaultPatterns();
    bool isPathIgnored(const QString& path) const;
    QString getRelativePath(const QString& path) const;
    bool isFileProcessable(const QString& filePath) const;
};

=== E:/repos/CPP_Codebase_Processor\MainWindow.cpp ===
#include "MainWindow.h"
#include "FileSystemModelWithGitIgnore.h"
#include "ProcessingDialog.h"
#include "FileProcessingWorker.h"

#include <QVBoxLayout>
#include <QPushButton>
#include <QTreeView>
#include <QFileDialog>
#include <QMessageBox>
#include <QFile>
#include <QTextStream>
#include <QDirIterator>
#include <QClipboard>
#include <QApplication>
#include <QFileSystemWatcher>
#include <QThread>
#include <QTimer>
#include <QStandardPaths>
#include <QItemSelectionModel>
#include <QDebug>

MainWindow::MainWindow(QWidget *parent) 
    : QMainWindow(parent)
    , workerThread(nullptr)
{
    // Only do minimal setup initially
    setWindowTitle("Codebase Processor");
    resize(800, 600);
    
    // Use QTimer to defer the rest of the initialization
    QTimer::singleShot(0, this, &MainWindow::delayedInit);
}

void MainWindow::delayedInit()
{
    setupUI();
    
    // Additional setup for file model
    fileModel->setFilter(QDir::AllEntries | QDir::NoDotAndDotDot | QDir::Hidden);
}

MainWindow::~MainWindow()
{
    // If there's an active worker thread, clean it up
    if (workerThread && workerThread->isRunning()) {
        workerThread->quit();
        workerThread->wait();
    }
}

void MainWindow::setupUI()
{
    centralWidget = new QWidget(this);
    setCentralWidget(centralWidget);
    mainLayout = new QVBoxLayout(centralWidget);

    // Create folder selection button
    selectFolderButton = new QPushButton("Select Codebase Folder", this);
    connect(selectFolderButton, &QPushButton::clicked, this, &MainWindow::selectFolder);
    mainLayout->addWidget(selectFolderButton);

    // Create tree view but defer model setup
    fileTreeView = new QTreeView(this);
    fileTreeView->setUniformRowHeights(true);
    fileTreeView->setEnabled(false);
    fileTreeView->setSortingEnabled(false); // Enable only after folder selection
    // Make sure multi-selection is enabled so multiple files can be selected
    fileTreeView->setSelectionMode(QAbstractItemView::MultiSelection);
    fileTreeView->setSelectionBehavior(QAbstractItemView::SelectRows);
    mainLayout->addWidget(fileTreeView);

    // Create action buttons
    saveFileButton = new QPushButton("Save to File", this);
    saveClipboardButton = new QPushButton("Copy to Clipboard", this);
    
    connect(saveFileButton, &QPushButton::clicked, this, &MainWindow::saveToFile);
    connect(saveClipboardButton, &QPushButton::clicked, this, &MainWindow::saveToClipboard);

    mainLayout->addWidget(saveFileButton);
    mainLayout->addWidget(saveClipboardButton);

    // Disable buttons initially
    saveFileButton->setEnabled(false);
    saveClipboardButton->setEnabled(false);

    // Initialize file system model
    fileModel = new FileSystemModelWithGitIgnore(this);
    fileModel->setReadOnly(true);
    fileTreeView->setModel(fileModel);

    // Set up selection handling after model is set
    connect(fileTreeView->selectionModel(), &QItemSelectionModel::selectionChanged,
            this, &MainWindow::handleSelectionChanged);

    // Set up gitignore watcher
    gitignoreWatcher = new QFileSystemWatcher(this);
    connect(gitignoreWatcher, &QFileSystemWatcher::fileChanged,
            this, &MainWindow::onGitIgnoreChanged);
}

void MainWindow::selectFolder()
{
    QString dir = QFileDialog::getExistingDirectory(
        this,
        "Select Codebase Directory",
        QString(),
        QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks
    );

    if (!dir.isEmpty()) {
        QApplication::setOverrideCursor(Qt::WaitCursor);
        
        // Use a timer to allow the UI to update
        QTimer::singleShot(0, this, [this, dir]() {
            currentPath = dir;
            
            // Set up the model with the new path
            QModelIndex rootIndex = fileModel->setRootPath(dir);
            fileTreeView->setRootIndex(rootIndex);
            
            // Update .gitignore patterns if present
            QString gitignorePath = dir + "/.gitignore";
            if (QFile::exists(gitignorePath)) {
                gitignoreWatcher->addPath(gitignorePath);
                fileModel->updateGitIgnorePatterns(dir);
            }
            
            // Expand the entire directory tree
            expandEntireDirectoryTree(rootIndex);

            // Manually populate selection
            QDir directory(dir);
            QStringList files = directory.entryList(
                QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot, 
                QDir::Name
            );
            
            selectedFiles.clear();
            for (const QString& fileName : files) {
                QString fullPath = dir + QDir::separator() + fileName;
                if (fileModel->shouldIncludeFile(fullPath)) {
                    selectedFiles.insert(fullPath);
                    qDebug() << "Manually adding:" << fullPath;
                }
            }
            
            qDebug() << "Manually selected files:" << selectedFiles.size();

            // Programmatically select these files in the tree
            fileTreeView->selectionModel()->clearSelection();
            for (const QString &filePath : selectedFiles) {
                QModelIndex index = fileModel->index(filePath);
                if (index.isValid()) {
                    fileTreeView->selectionModel()->select(
                        index,
                        QItemSelectionModel::Select | QItemSelectionModel::Rows
                    );
                }
            }
            
            // Enable UI elements
            fileTreeView->setEnabled(true);
            saveFileButton->setEnabled(true);
            saveClipboardButton->setEnabled(true);
            fileTreeView->setSortingEnabled(true);
            
            QApplication::restoreOverrideCursor();
        });
    }
}

void MainWindow::expandEntireDirectoryTree(const QModelIndex& parentIndex, int depth)
{
    // Prevent excessive recursion
    if (depth > 10) return;
    
    // Expand the current index
    fileTreeView->expand(parentIndex);
    
    // Get the number of rows (child items) for this parent
    int rows = fileModel->rowCount(parentIndex);
    
    // Iterate through all child items
    for (int i = 0; i < rows; ++i) {
        QModelIndex childIndex = fileModel->index(i, 0, parentIndex);
        
        // If this is a directory, recursively expand it
        if (fileModel->isDir(childIndex)) {
            expandEntireDirectoryTree(childIndex, depth + 1);
        }
    }
}

void MainWindow::handleSelectionChanged(const QItemSelection& selected, 
                                        const QItemSelection& deselected)
{
    // Process newly selected items
    for (const QModelIndex& index : selected.indexes()) {
        if (index.column() == 0) {  // Only process the first column
            QString filePath = fileModel->filePath(index);
            // Check if it's a file
            QFileInfo fileInfo(filePath);
            if (fileInfo.isFile()) {
                selectedFiles.insert(filePath);
                qDebug() << "Added to selection:" << filePath;
            }
        }
    }
    
    // Process deselected items
    for (const QModelIndex& index : deselected.indexes()) {
        if (index.column() == 0) {  // Only process the first column
            QString filePath = fileModel->filePath(index);
            selectedFiles.erase(filePath);
            qDebug() << "Removed from selection:" << filePath;
        }
    }
    
    qDebug() << "Total files selected:" << selectedFiles.size();
}

void MainWindow::expandDirectory(const QModelIndex& index, int depth)
{
    if (depth <= 0) return;
    
    fileTreeView->expand(index);
    int rows = fileModel->rowCount(index);
    
    for (int i = 0; i < rows; ++i) {
        QModelIndex childIndex = fileModel->index(i, 0, index);
        if (fileModel->isDir(childIndex)) {
            expandDirectory(childIndex, depth - 1);
        }
    }
}

void MainWindow::onGitIgnoreChanged()
{
    // When .gitignore changes, update the patterns and refresh the view
    fileModel->updateGitIgnorePatterns(currentPath);
}

void MainWindow::startFileProcessing(bool toClipboard)
{
    // Debug output to help diagnose selection issues
    qDebug() << "Starting processing with" << selectedFiles.size() << "files selected";
    for (const QString& file : selectedFiles) {
        qDebug() << "Selected file:" << file;
    }

    // Validate that we have files to process
    if (selectedFiles.empty()) {
        QMessageBox::warning(this, "No Files Selected",
                           "Please select files to process first.");
        return;
    }

    // Create a set of files that should actually be processed
    std::set<QString> filesToProcess;
    for (const QString& filePath : selectedFiles) {
        if (fileModel->shouldIncludeFile(filePath)) {
            QFileInfo fileInfo(filePath);
            if (fileInfo.isFile()) {
                filesToProcess.insert(filePath);
                qDebug() << "Will process:" << filePath;
            }
        }
    }

    if (filesToProcess.empty()) {
        QMessageBox::warning(this, "No Valid Files",
                           "None of the selected items can be processed. Please select valid files.");
        return;
    }

    // Create processing dialog
    auto* dialog = new ProcessingDialog(this);
    dialog->setWindowTitle(toClipboard ? "Copying to Clipboard" : "Saving to File");
    dialog->show();
    qApp->processEvents();

    // Create worker thread
    auto* worker = new FileProcessingWorker(currentPath, filesToProcess, fileModel);
    workerThread = new QThread(this);
    worker->moveToThread(workerThread);

    // Connect all signals
    connect(worker, &FileProcessingWorker::processingProgress, 
            dialog, &ProcessingDialog::setProgress);
    connect(worker, &FileProcessingWorker::currentFile,
            dialog, &ProcessingDialog::setCurrentFile);
    connect(worker, &FileProcessingWorker::statistics,
            dialog, &ProcessingDialog::updateStatistics);

    // Handle completion
    connect(worker, &FileProcessingWorker::finished, this, 
            [this, dialog, worker, toClipboard](const QString& result) {
        // Clean up worker thread
        workerThread->quit();
        worker->deleteLater();
        dialog->hide();

        // Get the final statistics
        int processedFiles = dialog->processedFiles() ;
        QString totalSize = dialog->formatFileSize(dialog->totalSize());

        if (result.isEmpty()) {
            QMessageBox::warning(this, "Processing Result", 
                               "No content was processed. Please check your file selection.");
        } else if (toClipboard) {
            QClipboard* clipboard = QApplication::clipboard();
            clipboard->setText(result);
            QMessageBox::information(this, "Success",
                QString("Content copied to clipboard successfully!\n\n"
                        "Files processed: %1\nTotal size: %2")
                .arg(processedFiles).arg(totalSize));
        } else {
            // Create a default filename
            QString defaultFileName = QFileInfo(currentPath).fileName() + "_processed.txt";
            QString defaultPath = QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);
            QString defaultFilePath = QDir(defaultPath).filePath(defaultFileName);

            QString savePath = QFileDialog::getSaveFileName(
                this,
                "Save Processed Code",
                defaultFilePath,
                "Text Files (*.txt);;Markdown Files (*.md);;All Files (*.*)",
                nullptr,
                QFileDialog::DontUseNativeDialog
            );

            if (!savePath.isEmpty()) {
                QFile file(savePath);
                if (file.open(QIODevice::WriteOnly | QIODevice::Text)) {
                    QTextStream out(&file);
                    out << result;
                    file.close();
                    QMessageBox::information(this, "Success",
                        QString("Files successfully processed and saved!\n\n"
                                "Files processed: %1\nTotal size: %2")
                        .arg(processedFiles).arg(totalSize));
                } else {
                    QMessageBox::critical(this, "Error",
                        "Could not save the file: " + file.errorString());
                }
            }
        }

        dialog->deleteLater();
    });

    // Handle errors
    connect(worker, &FileProcessingWorker::error, this, 
            [this, dialog](const QString& message) {
        dialog->hide();
        dialog->deleteLater();
        QMessageBox::critical(this, "Error", message);
    });

    // Ensure proper cleanup
    connect(workerThread, &QThread::finished, worker, &QObject::deleteLater);
    connect(workerThread, &QThread::finished, workerThread, &QObject::deleteLater);

    // Start processing
    connect(workerThread, &QThread::started, worker, &FileProcessingWorker::process);
    workerThread->start();

    qDebug() << "Processing thread started";
}

void MainWindow::saveToClipboard()
{
    startFileProcessing(true);
}

void MainWindow::saveToFile()
{
    startFileProcessing(false);
}

=== E:/repos/CPP_Codebase_Processor\MainWindow.h ===
// MainWindow.h
// This header defines our main application window and declares all its functionality.
#pragma once

#include <QMainWindow>
#include <QString>
#include <set>

// Forward declarations to reduce header dependencies
class QTreeView;
class QPushButton;
class QVBoxLayout;
class QFileSystemWatcher;
class FileSystemModelWithGitIgnore;
class ProcessingDialog;
class QItemSelection;

class MainWindow : public QMainWindow {
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = nullptr);
    ~MainWindow();

private slots:
    void selectFolder();
    void saveToFile();
    void saveToClipboard();
    void onGitIgnoreChanged();
    void handleSelectionChanged(const QItemSelection& selected, const QItemSelection& deselected);

private:
    void delayedInit();
    void setupUI();
    void expandDirectory(const QModelIndex& index, int depth);
    QString processFiles();
    void selectAllProcessableFiles(const QModelIndex& parentIndex);
    void expandEntireDirectoryTree(const QModelIndex& parentIndex, int depth = 0);
    void updateFileSelection(const QString& filePath, bool selected);

    // UI Elements
    QWidget *centralWidget{nullptr};
    QVBoxLayout *mainLayout{nullptr};
    QPushButton *selectFolderButton{nullptr};
    QTreeView *fileTreeView{nullptr};
    QPushButton *saveFileButton{nullptr};
    QPushButton *saveClipboardButton{nullptr};
    
    // Model and data handling
    FileSystemModelWithGitIgnore *fileModel{nullptr};
    QFileSystemWatcher *gitignoreWatcher{nullptr};
    QString currentPath;
    std::set<QString> selectedFiles;
    QThread* workerThread{nullptr};
    void startFileProcessing(bool toClipboard);
};


=== E:/repos/CPP_Codebase_Processor\ProcessingDialog.cpp ===
#include "ProcessingDialog.h"
#include <QVBoxLayout>
#include <QProgressBar>
#include <QLabel>
#include <QDebug>

ProcessingDialog::ProcessingDialog(QWidget* parent) 
    : QDialog(parent, Qt::Dialog | Qt::CustomizeWindowHint | Qt::WindowTitleHint) {
    setModal(true);

    mainLayout = new QVBoxLayout(this);
    
    // Main progress message
    messageLabel = new QLabel("Processing files...", this);
    messageLabel->setAlignment(Qt::AlignCenter);
    mainLayout->addWidget(messageLabel);

    // Current file being processed
    currentFileLabel = new QLabel("Waiting to start...", this);
    currentFileLabel->setAlignment(Qt::AlignLeft);
    currentFileLabel->setWordWrap(true);
    mainLayout->addWidget(currentFileLabel);

    // Statistics label
    statisticsLabel = new QLabel("Files processed: 0\nTotal size: 0 bytes", this);
    statisticsLabel->setAlignment(Qt::AlignLeft);
    mainLayout->addWidget(statisticsLabel);

    // Progress bar
    progressBar = new QProgressBar(this);
    progressBar->setMinimum(0);
    progressBar->setMaximum(100);
    progressBar->setValue(0);
    progressBar->setTextVisible(true);
    mainLayout->addWidget(progressBar);

    // Set a reasonable size for the dialog
    setFixedSize(500, 200);
    setWindowTitle("Processing");
}

void ProcessingDialog::setProgress(int current, int total) {
    if (total <= 0) return;
    
    int percentage = (current * 100) / total;
    progressBar->setValue(percentage);
    messageLabel->setText(QString("Processing files... (%1 of %2)").arg(current).arg(total));
    
    qDebug() << "Progress:" << current << "of" << total;
}

void ProcessingDialog::setCurrentFile(const QString& filePath) {
    QString displayPath = filePath;
    int lastSlash = displayPath.lastIndexOf('/');
    if (lastSlash == -1) lastSlash = displayPath.lastIndexOf('\\');
    
    if (lastSlash != -1) {
        QString fileName = displayPath.mid(lastSlash + 1);
        QString directory = displayPath.left(lastSlash);
        currentFileLabel->setText(QString("Current file: %1\nIn: %2").arg(fileName).arg(directory));
    } else {
        currentFileLabel->setText(QString("Current file: %1").arg(displayPath));
    }
    
    qDebug() << "Processing file:" << filePath;
}

QString ProcessingDialog::formatFileSize(qint64 size) const {
    const char* units[] = {"bytes", "KB", "MB", "GB"};
    int unitIndex = 0;
    double fileSize = size;

    while (fileSize >= 1024 && unitIndex < 3) {
        fileSize /= 1024;
        unitIndex++;
    }

    return QString("%1 %2")
        .arg(fileSize, 0, 'f', unitIndex > 0 ? 2 : 0)
        .arg(units[unitIndex]);
}

void ProcessingDialog::updateStatistics(int processedFiles, qint64 totalSize) {
    m_processedFiles = processedFiles;
    m_totalSize = totalSize;
    statisticsLabel->setText(QString("Files processed: %1\nTotal size: %2")
        .arg(processedFiles)
        .arg(formatFileSize(totalSize)));
    
    qDebug() << "Statistics update - Files:" << processedFiles << "Size:" << formatFileSize(totalSize);
}

=== E:/repos/CPP_Codebase_Processor\ProcessingDialog.h ===
#pragma once

#include <QDialog>
#include <QString>

class QProgressBar;
class QLabel;
class QVBoxLayout;

class ProcessingDialog : public QDialog {
    Q_OBJECT

public:
    explicit ProcessingDialog(QWidget* parent = nullptr);
    int processedFiles() const { return m_processedFiles; }
    qint64 totalSize() const { return m_totalSize; }
    QString formatFileSize(qint64 size) const;

public slots:
    void setProgress(int current, int total);
    void setCurrentFile(const QString& filePath);
    void updateStatistics(int processedFiles, qint64 totalSize);

private:
    QVBoxLayout* mainLayout;
    QLabel* messageLabel;
    QLabel* currentFileLabel;
    QLabel* statisticsLabel;
    QProgressBar* progressBar;
    int m_processedFiles = 0;
    qint64 m_totalSize = 0;
};


=== E:/repos/CPP_Codebase_Processor\README.md ===
# Codebase Processor

A **Qt-based C++** application for processing codebases into a single text file. It allows you to select a folder, choose which files to process based on customizable filters, and then either copy the processed content to your clipboard or save it to a single output file.

## Features

- Recursively scans a selected directory and its subdirectories for code files
- Supports filtering files based on customizable patterns, including a `.gitignore` file if present
- Provides a tree view UI to select individual files to include/exclude from processing
- Concatenates the contents of selected files into a single output, with file paths as headers
- Option to copy the output directly to clipboard or save to a file
- Provides progress updates and statistics during processing
- Cross-platform support (Windows, macOS, Linux)

## Prerequisites

- **Qt 6.8** or higher (adjust `CMAKE_PREFIX_PATH` in `CMakeLists.txt` if needed)
- **CMake 3.16** or higher
- A **C++17** compatible compiler (MSVC, GCC, Clang)
- On Windows, a **Visual Studio Developer Command Prompt** to properly configure the build environment

## Build Instructions

### Automatic Build (Windows)

1. Open a **Developer Command Prompt for Visual Studio**
2. Run either `build_deploy_release.bat` for a Release build or `build_deploy_debug.bat` for a Debug build

The batch file will:
- Set up the Visual Studio build environment 
- Create a `build` directory
- Configure and build the project with CMake
- Deploy the necessary Qt dependencies next to the executable

You can find the final executable in `build\Release` or `build\Debug` depending on the selected build type.

### Manual Build

1. **Create a build directory**: `mkdir build` (or use your preferred build directory setup)
2. **Configure the project with CMake**:
   ```
   cd build
   cmake .. -DCMAKE_BUILD_TYPE=Release
   ```
   (Replace `Release` with `Debug` if you want a debug build)
3. **Build the project**:
   ```
   cmake --build . --config Release
   ```
4. The compiled executable will be in the `Release` or `Debug` subfolder, depending on your build type.

On Windows, you'll also need to run `windeployqt` to copy the necessary Qt dependencies next to the executable:
```
<path_to_qt>\bin\windeployqt.exe --release --no-translations --no-system-d3d-compiler Release\codebase_processor.exe  
```
(Adjust the path to `windeployqt.exe` and the executable as needed)

## Usage

1. Launch the `codebase_processor` executable
2. Click the **"Select Codebase Folder"** button and choose the root directory of the codebase you want to process
3. The file tree will populate with all the code files found in the selected directory and its subdirectories
   - Files ignored based on patterns in a `.gitignore` file (if present) or common binary/build output patterns will be unchecked by default
   - You can manually check/uncheck files to include or exclude them from processing
4. Click **"Copy to Clipboard"** to concatenate the contents of all checked files and copy the result to the clipboard
   - OR click **"Save to File"** to save the concatenated content to a file instead
5. A progress dialog will show the current processing status and statistics
6. Once complete, the processed content will be in your clipboard or saved file

## Contributing

Contributions are welcome! If you encounter any issues or have suggestions for improvements, please open an issue or submit a pull request on the GitHub repository.

## License

This project is open-source and available under the [MIT License](LICENSE).

=== E:/repos/CPP_Codebase_Processor\build_deploy_debug.bat ===
@echo off
setlocal enabledelayedexpansion

:: Check if VS Developer Command Prompt variables are set
if not defined VSINSTALLDIR (
    echo Setting up Visual Studio environment...
    call "E:\Microsoft Visual Studio\2022\Community\Common7\Tools\VsDevCmd.bat"
)

:: Create and enter build directory
if not exist build mkdir build
cd build

:: Configure with CMake
echo Configuring with CMake...
cmake .. -DCMAKE_BUILD_TYPE=Debug

:: Build the project
echo Building the project...
cmake --build . --config Debug

:: Check if build was successful
if %ERRORLEVEL% NEQ 0 (
    echo Build failed!
    pause
    exit /b 1
)

echo Build completed successfully!
echo You can find the executable in build\Debug\
echo Don't forget to run the program from that directory!

pause

=== E:/repos/CPP_Codebase_Processor\build_deploy_release.bat ===
@echo off
setlocal enabledelayedexpansion

:: Check if VS Developer Command Prompt variables are set
if not defined VSINSTALLDIR (
    echo Setting up Visual Studio environment...
    call "E:\Microsoft Visual Studio\2022\Community\Common7\Tools\VsDevCmd.bat"
)

:: Create and enter build directory
if not exist build mkdir build
cd build

:: Configure with CMake for a Release build
echo Configuring with CMake for Release...
cmake .. -DCMAKE_BUILD_TYPE=Release

:: Build the project in Release mode
echo Building the project in Release mode...
cmake --build . --config Release

:: Check if the build was successful
if %ERRORLEVEL% NEQ 0 (
    echo Build failed!
    pause
    exit /b 1
)

:: Optional: Manually run windeployqt in Release mode if needed.
:: Only do this if you want to deploy again outside the built-in CMake steps.
::
:: echo Running windeployqt for Release...
:: "E:\QT\6.8.2\msvc2022_64\bin\windeployqt.exe" --release ^
::     --no-translations ^
::     --no-system-d3d-compiler ^
::     "Release\codebase_processor.exe"

echo Build completed successfully!

:: If you're using the default Visual Studio generator, the final exe is likely in build\Release.
echo You can find the executable in build\Release\ (if using Visual Studio).
echo If using Ninja or MinGW, the exe will be directly in build\.

pause


=== E:/repos/CPP_Codebase_Processor\main.cpp ===
// main.cpp
// This is the entry point of our application. It sets up the Qt application object
// and creates our main window.
#include <QApplication>
#include "MainWindow.h"

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    app.setWindowIcon(QIcon(":/app_icon.png"));
    
    MainWindow window;
    window.show();
    return app.exec();
}

